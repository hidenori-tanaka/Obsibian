### B1.5 Armv7-M exception model

Armv7-M プロファイルは、例外の入り口および出口で **主要なコンテキスト状態をハードウェアによって自動的に保存・復元する** 点や、  
**例外のエントリポイントを示すためにベクタテーブルを使用する** 点で、他の Armv7 プロファイルと異なっています。  
さらに、Armv7-M プロファイルでは、**例外の分類（exception categorization）も他の Armv7 プロファイルとは異なります。**

以下のセクションでは、Armv7-M の例外モデルについて説明します：

- サポートされている例外の概要
- **例外番号の定義**（B1-525 ページ）    
- **ベクタテーブル**（B1-525 ページ）    
- **例外優先度とプリエンプション**（B1-526 ページ）    
- **リセット動作**（B1-530 ページ）    
- **例外エントリ時の動作**（B1-531 ページ）    
- **例外エントリ時のスタックアラインメント**（B1-535 ページ）    
- **例外リターン時の動作**（B1-539 ページ）    
- **単一ワードロード命令での例外**（B1-543 ページ）    
- **Load Multiple / Store Multiple 命令での例外**（B1-543 ページ）    
- **例外エントリ時に発生する例外**（B1-546 ページ）    
- **例外リターン時の例外、およびテールチェーニング例外**（B1-548 ページ）    
- **例外ステータスと制御**（B1-550 ページ）    
- **フォルトの動作**（B1-551 ページ）    
- **回復不能な例外のケース**（B1-555 ページ）    
- **リセット管理**（B1-559 ページ）    
- **電源管理**（B1-559 ページ）    
- **Wait For Event（WFE）と Send Event（SEV）**（B1-560 ページ）    
- **Wait For Interrupt（WFI）**（B1-562 ページ）

#### B1.5.1 Overview of the exceptions supported

**Armv7-M プロファイルがサポートする例外**

- **Reset（リセット）**
	Armv7-M プロファイルは **2 種類のリセットレベル**をサポートします。  
	リセットレベルは、リセット解除時にどのレジスタのビットフィールドがリセット値へ強制的に戻されるかを決定します。
	- **Power-on reset（電源オンリセット）**  
	    プロセッサ、System Control Space、デバッグロジックをリセットします。
	- **Local reset（ローカルリセット）**  
	    プロセッサと System Control Space をリセットしますが、一部のフォルト関連およびデバッグ関連資源は除外されます。  
	    詳細は C1-693 ページの「Debug and reset」を参照。
	Reset 例外は常に有効で、優先度 -3 に固定されています。

- **NMI（Non-Maskable Interrupt、マスク不可割り込み）**
	Reset を除くすべての例外の中で **最高優先度**を持ちます。  
	NMI は常に有効で、優先度 -2 に固定されています。
	
	NMI はハードウェアが生成できるほか、ソフトウェアが NMI 例外を Pending 状態に設定することもできます（B3-599 の ICSR を参照）。

 - **HardFault**
	他の例外メカニズムで処理できないすべての種類のフォルトに対する汎用フォルトです。
	通常、HardFault は回復不能なシステムエラーの処理に使われますが、必ずしも回復不能とは限らず、回復可能な HardFault もあり得ます。
	HardFault は常に有効で、優先度 -1 に固定されています。
	HardFault は **フォルトエスカレーション**に使用されます（B1-529 の Priority escalation を参照）。

-  **MemManage（メモリ管理フォルト）**
	MPU または固定的なメモリ保護制約によって決まるメモリ保護違反を扱います。  
	命令とデータの両方のメモリアクセスに適用されます。
	
	ソフトウェアはこのフォルトを無効化できます。  
	無効化すると、MemManage フォルトは **HardFault へエスカレート**します。
	
	MemManage には **設定可能な優先度**があります。

-  **BusFault（バスフォルト）**
	MemManage が扱わない **メモリ関連フォルト** を処理します。  
	命令アクセスとデータアクセスの両方に適用されます。
	
	多くの場合、これはシステムバス上で検出されたエラーにより発生します。
	
	BusFault は **同期的または非同期的** に報告される場合があり、これは実装および例外を引き起こす状況に依存します。
	
	ソフトウェアはこのフォルトを無効化できます。  
	無効化すると、BusFault は **HardFault へエスカレート**します。
	
	BusFault も **設定可能な優先度**を持ちます。

-  **UsageFault（使用フォルト）**
	命令実行により発生する **非メモリ関連フォルト** を扱います。  
	以下のような状況で発生します：
	- 未定義命令    
	- 無効な状態での命令実行
	- 例外リターン時のエラー
    - 無効または未使用のコプロセッサへのアクセス
    また、プロセッサ設定によっては以下も sageFault を発生させます：
	- ワードまたはハーフワードの **未アラインド（非アライン）アクセス**
    - ゼロ除算（divide-by-zero）
    
	ソフトウェアは UsageFault を無効化できます。  
	無効化すると、UsageFault は **HardFault へエスカレート**します。
	
	UsageFault も **設定可能な優先度**を持ちます。

-  **DebugMonitor（デバッグモニタ例外）**
	一般的に DebugMonitor は **同期例外**であり、フォルトとして分類されます。
	DebugMonitor は Halting Debug（停止型デバッグ）が無効になっており、かつ DebugMonitor 例外が有効な場合に発生します。
	DebugMonitor には設定可能な優先度があります。  
	詳細は B1-529 の Priority escalation や C1-694 の Debug event behavior を参照。
	
	**注:**  
	デバッグのウォッチポイントは **非同期的** であり、割り込みとして扱われます。

-  **SVCall（Supervisor Call）**
	SVC 命令により発生する例外です。
	SVCall は常に有効で、設定可能な優先度を持ちます。

- **Interrupts（割り込み）**
	Armv7-M プロファイルは **2 つのシステムレベル割り込み**と、最大 **496 の外部割り込み**をサポートします。  
	すべての割り込みは設定可能な優先度を持ちます。
	
	システムレベル割り込みは以下の 2 つ：
	-  **PendSV（ペンディング SVC）**
		- ソフトウェア生成のシステムコールに使用される。 OS が必要とするサービスに対応する Supervisor Call は SVC 命令を使うが、  PendSV は「遅延実行される SVC」のようなもの
	    - ICSR.PENDSVSET / ICSR.PENDSVCLR によって制御
		- 常に有効
		**注:**  
		同期的な SVC を行いたい場合は **SVC 命令を使用**し、SVCall 例外を発生させる。
	
	- **SysTick（システムタイマー割り込み）**
		- Armv7-M プロセッサに統合された SysTick タイマーによって生成
	    - 常に有効で、ICSR.PENDSTSET / ICSR.PENDSTCLR により制御可能
	    **注:**  
		ハードウェアによる SysTick イベント生成はソフトウェアで抑止できるが、  
		ICSR.PENDSTSET / PENDSTCLR は常に利用可能。
	ソフトウェアはすべての外部割り込みを無効化でき、  任意の割り込みの Pending 状態をセット／クリアできます。  
	また、PendSV を除く割り込みはハードウェアによって Pending 状態に設定されることがあります。

フォルトの原因、フォルトの種類、フォルトの特定に使用されるステータスレジスタの詳細については、  **B1-551 の Fault behavior** を参照してください。

### Exception number definition

![[Pasted image 20251213152331.png]]

###  Vector Table

ベクタテーブルには、
- **スタックポインタの初期値**
- **各例外ハンドラのエントリポイントアドレス**  
が含まれます。

例外番号（Table B1-4 で定義）は、**ベクタテーブル内のエントリ順序**も定義します（Table B1-5 参照）。

リセット時、プロセッサは **ベクタテーブルベースアドレスを IMPLEMENTATION DEFINED（実装依存）アドレスに初期化**します。
ソフトウェアは、
- 現在のベクタテーブルの位置を取得、または
- テーブルを再配置（relocate） 
	するために **VTOR（Vector Table Offset Register）** を使用できます。  
    （B3-601 の VTOR を参照）
**注意：**  
リセットには _power-on reset_ と _Local reset_ の 2 種類があります（B1-523 の「例外の概要」、および B1-559 の「Reset management」参照）。

ベクタテーブルは、次の条件を満たす自然アラインメント（Natural Alignment）で配置されなければなりません：
- アラインメントは **2 の累乗**
- アライン値は **(サポートされる例外数 × 4) 以上**
- 最小アラインメントは **128 バイト**

**電源投入時またはリセット時の特別な要件**
- プロセッサは **オフセット 0 のエントリを SP_main（メインスタックポインタ）初期値として使用**します  
    （B1-516「SP レジスタ」参照） 
- **その他すべてのエントリ（例外ハンドラアドレス）は bit[0] を 1 に設定する必要があります**  
    → bit[0] は、例外突入時の **EPSR.T（Thumb 状態ビット）** を定義するため
	（B1-530 の「Reset behavior」、B1-531 の「Exception entry behavior」参照）

**bit[0] が 0 の場合に発生するフォルト**
例外突入時、対応するベクタテーブルエントリの bit[0] が **0** の場合：
- 最初の命令を実行した時点で **INVSTATE UsageFault（無効状態フォルト）** が発生  
    （B1-516「xPSR」、B1-551「Fault behavior」参照）
さらに、リセット時にこれが発生すると：
- UsageFault はリセット直後は無効化されているため
- **HardFault へエスカレート**します  
    （B1-529「Priority escalation」参照）

### B1.5.4 Exception priorities and preemption

Armv7-M の優先度モデルでは、**数値が小さいほど優先度が高くなります**。  
つまり、割り当てられた優先度値が低いほど、例外の優先順位は高くなります。

同じ優先度レベルを持つ例外同士の優先順位は固定であり、**例外番号によって決定**されます。

これら 3 つの例外は、固定の優先度で実行されます：

| 例外        | 固定優先度  |
| --------- | ------ |
| Reset     | **-3** |
| NMI       | **-2** |
| HardFault | **-1** |

ソフトウェアは、これら以外のすべての例外の優先度を System Control Space のレジスタを使って設定できます。

ソフトウェアで設定される優先度値は **0 が最小値（最も高い優先度）** です。  
そのため、Reset / NMI / HardFault は **他のどの例外よりも常に高い優先度**を持ちます。

リセットが発生すると、ソフトウェアが設定した例外優先度レジスタは **すべて 0 にクリア**されます。  
これは、設定可能な優先度の中で最も高い（=最優先）値です。

複数の pending 例外が同じ優先度値を持つ場合：

- **例外番号が最も小さいものが優先される**
	例：
	- 優先度 3 の SysTick と EXTI0 が pending → 例外番号が小さい SysTick が先に実行。
    すでにアクティブな例外がある場合、  
	**それより高い優先度（より小さい数値）の例外だけがプリエンプト可能**です。

ソフトウェアが pending または active 状態の例外の優先度を変更する場合、  
**命令ストリームとの同期が必須**です。

詳細は A3-96 の  
**「System Control Space 更新の同期要件」**  
を参照。

サポートされる優先度レベル数は IMPLEMENTATION DEFINED（実装依存）であり、
- **8 ～ 256 の範囲の 2 の累乗**    
- 最低優先度値は常に **0**    
- 優先度フィールドは常に **8 ビット**    

もし実装が 256 未満の優先度レベルしかサポートしない場合、  
優先度フィールドの **下位ビットは RAZ（Read-As-Zero）** となります。

| 優先度ビット数 | 優先度レベル数 | 最大優先度値（＝最も低い優先度） |
| ------- | ------- | ---------------- |
| 例：3 ビット | 8 レベル   | 7                |
| 例：4 ビット | 16 レベル  | 15               |
| 例：5 ビット | 32 レベル  | 31               |
| ...     | ...     | ...              |

（表の末尾に記載されている “a” は、この値が常に「最も低い例外優先度」に対応することを示す注釈）z

####  Priority grouping

**優先度グルーピング**とは、例外の優先度を次の 2 つに分割する仕組みです：
1. **グループ優先度（Group Priority）**    
2. **サブ優先度（Subpriority）**    

これにより、
- **プリエンプション（実行の中断）** は _グループ優先度_ によって決まり、    
- **同じグループ内の優先順位決定** は _サブ優先度_ によって行われます。    

優先度フィールドは 8 ビットですが、  この 8 ビットのうち **どれだけをサブ優先度に割り当てるか** を決めるのが **AIRCR.PRIGROUP フィールド**です
（AIRCR = Application Interrupt and Reset Control Register）

Table B1-7 は、  **PRIGROUP の値に応じて優先度フィールドがどのように分割されるか**を示します。
![[Pasted image 20251213154010.png]]

例（概念的な説明）：

| PRIGROUP | Group Priority Bits | Subpriority Bits |
| -------- | ------------------- | ---------------- |
| 0        | 多い                  | 少ない              |
| 3        | 中間                  | 中間               |
| 7        | 少ない                 | 多い               |

PRIGROUP は **優先度フィールドの「小数点位置（binary point）」を決める** と表現されます。

- **グループ優先度がプリエンプションを決定**  
    → グループ優先度が低い（＝高い優先度）の例外が、現在の例外や Thread の実行を中断できる。    
- **グループ優先度が同じ Pending 例外が複数ある場合**  
    → ハードウェアは **サブ優先度** を使って順番を決定する。    

以下の例外については **PRIGROUP の設定に関係なく固定**です：

| 例外        | グループ優先度 |
| --------- | ------- |
| Reset     | **-3**  |
| NMI       | **-2**  |
| HardFault | **-1**  |

これらは ARMv7-M の中で最も高い優先度を持ち、  ソフトウェアによって変更することはできません。
