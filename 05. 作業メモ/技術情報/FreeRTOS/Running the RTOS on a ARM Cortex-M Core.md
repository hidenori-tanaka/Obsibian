**注意:**  
このページで説明されている **割り込みネスト（割り込みの入れ子）に関する情報は、Cortex-M3、Cortex-M4、Cortex-M4F、Cortex-M7、Cortex-M33、および Cortex-M23 を使用する場合に適用されます。  
**Cortex-M0 および Cortex-M0+ コアには BASEPRI レジスタが存在しないため、これらには当てはまりません。**
# Introduction

多くの何千ものアプリケーションが、ARM Cortex-M コア上で FreeRTOS を動作させています。  
それにもかかわらず、この RTOS と ARM Cortex CPU コアの組み合わせに関する技術サポートの問い合わせが非常に少ないことは、むしろ驚くべきことです。

実際に発生する問題の大半は、**割り込み優先度設定の誤り**が原因です。  
これはある意味当然とも言えます。なぜなら、ARM Cortex-M コアが採用している割り込みモデルは強力ではあるものの、より一般的な割り込み優先度方式に慣れたエンジニアにとっては、**やや扱いにくく直感的でない**部分があるためです。

このページの目的は、ARM Cortex-M の割り込み優先度メカニズムを説明し、それを RTOS カーネルと共にどのように利用すべきかを説明することです。

なお、ARM Cortex-M3 コアが採用している優先度方式は複雑に見えるかもしれませんが、**FreeRTOS のすべての公式ポートには、正しく設定されたデモアプリケーションが付属しており、リファレンスとして使用できます。**

さらに、FreeRTOS V7.5.0 では、**ARM Cortex-M の割り込みコントローラ（NVIC）の設定ミスを検出するための configASSERT() 呼び出しが追加**されました。  
開発時には必ず **configASSERT() を有効にしてください。**
# Available Priority Levels

## Cortex-M hardware details

まず知っておくべきことは、**利用可能な割り込み優先度（priority）の総数は実装依存であり、ARM Cortex-M コアを搭載したマイクロコントローラを製造するメーカーに委ねられている**という点です。  
その結果、**すべての ARM Cortex-M マイクロコントローラで同じ数の割り込み優先度が利用できるわけではありません**。

ARM Cortex-M アーキテクチャ自体は **最大 256 種類の優先度**を扱うことができます（優先度ビットは最大 8 ビットで、0〜0xFF の範囲が設定可能）。  
しかし、実際のマイクロコントローラでは、このうちの一部のビットにしかアクセスできないことがほとんどです。

例えば：

- **TI Stellaris Cortex-M3 / Cortex-M4** マイクロコントローラは **3 ビットの優先度**を実装しており、  
    → **8 種類の優先度値**が利用できます。   
- **NXP LPC17xx Cortex-M3** マイクロコントローラは **5 ビットの優先度**を実装しており、  
    → **32 種類の優先度値**が利用できます。
   
プロジェクトで **CMSIS のヘッダーファイル**を含んでいる場合は、  
**`__NVIC_PRIO_BITS`** の定義を確認することで、そのデバイスで利用可能な優先度ビット数を知ることができます。
## Relevance when using the RTOS

RTOS の割り込みネスティング方式では、**利用可能な割り込み優先度を2つのグループに分割**します。

1. **RTOS のクリティカルセクションによってマスク（無効化）される割り込みグループ**
2. **RTOS のクリティカルセクションでは決してマスクされず、常に有効な割り込みグループ**

FreeRTOSConfig.h にある **`configMAX_SYSCALL_INTERRUPT_PRIORITY`** は、  この **2つのグループを分ける境界となる優先度** を定義します。
この設定に適切な値は、  **マイクロコントローラで実装されている優先度ビット数によって異なります。**
# Preempt Priority and Subpriority

## Cortex-M hardware details

8ビットの優先度レジスタは **「プリエンプト優先度（preempt priority）」** と  **「サブ優先度（sub priority）」** の2つに分割されます。  
それぞれに割り当てられるビット数は **設定によって変更可能** です。

- **プリエンプト優先度**  
    → すでに実行中の割り込みを、別の割り込みが**割り込んで実行できるかどうか**を決める。
- **サブ優先度**  
    → **同じプリエンプト優先度を持つ割り込みが同時に発生した場合**,  
    **どちらを先に実行するか**を決める。
## Relevance when using the RTOS

すべての優先度ビットを **プリエンプト優先度ビットに割り当て**,  **サブ優先度ビットを 0 にする**ことが推奨されています。

それ以外の設定を行うと、  
`configMAX_SYSCALL_INTERRUPT_PRIORITY` と  
各ペリフェラル割り込みに割り当てる優先度との **本来シンプルな関係が複雑になってしまうため** です。

多くのシステムでは、この望ましい構成がデフォルトとなっています。  
ただし notable（目立った）例外として **STM32 のドライバライブラリ** があります。

もし STM32 を STM32 公式ドライバライブラリと共に使用している場合は、  
RTOS を起動する前に以下を呼び出して、  **すべての優先度ビットがプリエンプト優先度ビットとして扱われるように設定してください**：
`NVIC_PriorityGroupConfig( NVIC_PriorityGroup_4 );`

この要件を満たさないと、FreeRTOS の割り込み優先度ルールが正しく働かず、  思わぬ動作不良につながる可能性があります。

### Inverse Relationship Between Numeric Priority Value and the Logical Priority Setting

### Cortex-M hardware details

次に理解しておくべきことは、**ARM Cortex-M コアでは、数値として小さい優先度値が“論理的に高い割り込み優先度”を表す**という点です。

たとえば：

- 数値優先度 **2** を持つ割り込みは、
- 数値優先度 **5** を持つ割り込みより **論理的に高い優先度** です。

つまり、数値が小さいほど割り込みの優先順位が高くなります。

この関係を明確にすると：

- **優先度 2 の割り込みは、優先度 5 の割り込みを「割り込んで実行」できます（ネスト可能）**
- **しかし、優先度 5 の割り込みは、優先度 2 の割り込みを割り込むことはできません**

---

これは ARM Cortex-M の割り込み優先度で最も **直感に反するポイント** です。  
というのも、これは **多くの（Cortex-M 以外の）マイクロコントローラにおける一般的な優先度の考え方とは逆** だからです。

### Relevance when using the RTOS

FreeRTOS では、名前が **"FromISR" で終わる関数は割り込みセーフ**として設計されています。  
しかし、このような関数であっても、**configMAX_SYSCALL_INTERRUPT_PRIORITY**  
（FreeRTOSConfig.h に定義）よりも **論理的に高い優先度** を持つ割り込みから呼び出すことはできません。

したがって、**RTOS の API を使用する割り込みサービスルーチン（ISR）** は、  
その割り込みの優先度を必ず手動で設定し、  
`configMAX_SYSCALL_INTERRUPT_PRIORITY` の値 **以上の数値（＝論理優先度としては同じか低い）** にする必要があります。

こうすることで、その割り込みの **論理優先度が configMAX_SYSCALL_INTERRUPT_PRIORITY と等しいか、より低い（＝安全な）優先度** であることが保証されます。

---

### ⚠ Cortex-M の割り込みはデフォルトで _優先度 0_

Cortex-M の割り込みは、**デフォルトでは優先度値 0 に設定されています**。  
この **0 は最も高い優先度** です。

したがって、

> **RTOS API（FromISR 系）を使用する割り込みの優先度をデフォルトの 0 のまま使用してはいけません。**

必ず優先度を、  
**数値として configMAX_SYSCALL_INTERRUPT_PRIORITY 以上**  
に設定してください。

### Cortex-M Internal Priority Representation

#### Cortex-M hardware details

ARM Cortex-M コアは、**8 ビットの割り込み優先度レジスタの上位ビット（MSB 側）に優先度値を格納**します。

たとえば、ある ARM Cortex-M マイクロコントローラの実装が  
**3 ビットの優先度ビットしかサポートしていない場合**、  
その 3 ビットは次のように **ビット 5、6、7 にシフトされて格納されます**。

- 優先度ビット → 割り込み優先度レジスタの bit7, bit6, bit5 に配置  
- bit0〜bit4 はどんな値でも構いませんが、  
    **将来の互換性のために 1 に設定しておくことが推奨**されます。

---

### ARM Cortex-M 内部での優先度の表現

ARM Cortex-M が内部的に割り込み優先度をどのように格納しているかを示しています。

![[Pasted image 20251212121840.png]]

Cortex-M の優先度レジスタは、最大で **8 ビットの優先度ビット** を格納できるようになっています。

しかし、例えば **マイクロコントローラが 3 ビットの優先度しか実装していない場合**、  
実際に使用されるのは **レジスタの上位 3 ビット（最上位ビット側）** だけです。

![[Pasted image 20251212122021.png]]

上記の図は、**3 ビットの優先度ビットを実装しているマイクロコントローラ**において、  
値 **5（2 進数 101）** がどのように優先度レジスタに格納されるかを示しています。

この図は次の理由を説明しています：

- 元の値 **5（2進数 0000 0101）** は
- 優先度ビット（上位 3 ビット）として配置されると、**101 がビット 7〜5 にシフト**され
- 残りのビット（bit4〜bit0）が **1 に設定**されるので最終的にこの値は、**191（2進数 1011 1111）**

としても表せる、ということです。

![[Pasted image 20251212122151.png]]

上記の図は、**4 ビットの優先度ビットを実装しているマイクロコントローラ**において、  
値 **5（2 進数 101）** がどのように優先度レジスタに格納されるかを示しています。

この図は次のことを説明しています：

- 元の値 **5（2進数 0000 0101）** は
- 優先度ビット（上位 4 ビット）として配置されると、**0101 がビット7〜4 にシフトされ**
- 残りのビット（bit3〜bit0）が **1 に設定**されるため結果としてこの値は、**95（2進数 0101 1111）**としても表せる、ということです。

### Relevance when using the RTOS

上述のように、**RTOS API を使用する割り込みサービスルーチン（ISR）は、  
configMAX_SYSCALL_INTERRUPT_PRIORITY で設定された値 “以下の論理優先度”（＝数値としては同じか大きい値）  
を持たなければならない** ことが非常に重要です。

（※論理優先度が低い ＝ 数値が大きい）

---

### 🔧 割り込み優先度を設定する際の注意（CMSIS / 各社ライブラリ）

CMSIS や MCU メーカーが提供するライブラリには、  
割り込みの優先度を設定するための関数があります。

しかし、これには **2 種類の仕様** が存在します：

1. **優先度値を 8ビットの下位ビット（LSB側）に指定するもの**
2. **優先度値を、あらかじめ 8ビットの上位ビット（MSB側）にシフトした状態で指定するもの**

どちらを要求しているかはライブラリ関数の仕様によって異なるため、  
**呼び出す関数のドキュメントを必ず確認してください。**

これを誤ると、**意図しない割り込み優先度になり、RTOS が正常に動作しなくなる可能性があります**。

---

### ⚙ FreeRTOSConfig.h の設定値は「すでに上位ビットへシフトした形式」で指定する必要がある

`configMAX_SYSCALL_INTERRUPT_PRIORITY` と  
`configKERNEL_INTERRUPT_PRIORITY`  
は、ARM Cortex-M コアが内部で使用する形式に合わせて、

➡ **すでに優先度ビットを上位ビット（MSB側）にシフトした値**  
を設定する必要があります。

---

### 🟦 なぜ configKERNEL_INTERRUPT_PRIORITY は 255（0xFF）なのか？

FreeRTOS の公式デモでは、

`#define configKERNEL_INTERRUPT_PRIORITY 255 // 1111 1111`

となっています。

これは、255 を指定することで：

- 8ビット優先度レジスタの **上位ビットがすべて 1**
- → **最も低い論理優先度**
- → **RTOS カーネルの割り込みが他の割り込みに邪魔されない**

という正しい動作が得られるためです。

このような指定方法が選ばれている理由は以下の通りです：

- FreeRTOS カーネルは **直接 Cortex-M3 ハードウェアを操作する**（サードパーティライブラリを使用しない）
- RTOS カーネルの実装は **各メーカーのライブラリが普及する前に設計された**
- 当時市場に最初に登場した Cortex-M3 ライブラリが **この方式（上位ビット形式）を採用していた**

### Critical Sections

### Cortex-M hardware details

RTOS カーネルは、ARM Cortex-M コアの **BASEPRI レジスタ** を使って  
クリティカルセクションを実装しています。  
これにより RTOS は、**割り込み全体ではなく特定の優先度以下の割り込みだけをマスク**でき、  
柔軟な割り込みネスティング（入れ子）モデルを実現できます。

---

### 🔧 BASEPRI の動作

BASEPRI は **ビットマスク（bit mask）** として動作し、

> **BASEPRI にある値を設定すると、その値と同じ優先度、および論理的に下位の優先度を持つすべての割り込みがマスクされる（禁止される）。**

つまり、

- 論理的に「高い優先度」（＝数値が小さい）割り込みはマスクされず、
- **優先度 0 の割り込みを BASEPRI でマスクすることは不可能**  
    （優先度 0 は最も高い論理優先度のため）

---

### 📝 補足：FromISR 関数と BASEPRI の関係

割り込みから呼び出しても安全な FreeRTOS API（"FromISR" で終わる関数）は、  
内部で BASEPRI を使って安全なクリティカルセクションを実現しています。

- クリティカルセクションに入るとき  
    → BASEPRI に **configMAX_SYSCALL_INTERRUPT_PRIORITY** を設定
- クリティカルセクションを抜けるとき  
    → BASEPRI を **0 に戻す**

### Relevance to the RTOS kernel

RTOS カーネルは、  
**configMAX_SYSCALL_INTERRUPT_PRIORITY の値を ARM Cortex-M の BASEPRI レジスタに書き込むことで  
クリティカルセクションを作ります。**

しかし、

- **優先度 0 の割り込み（最も高い優先度）は BASEPRI ではマスクできない**
    

という Cortex-M の仕様があります。

そのため、

> **configMAX_SYSCALL_INTERRUPT_PRIORITY を 0 に設定してはいけません。**

0 を設定してしまうと、BASEPRI でマスクされる割り込みが存在しなくなり、  
RTOS が意図した割り込み制御ができなくなります。